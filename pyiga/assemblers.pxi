# file generated by generate-assemblers.py

################################################################################
# 2D Assemblers
################################################################################

cdef class BaseAssembler2D:
    cdef int nqp
    cdef size_t[2] ndofs
    cdef vector[ssize_t[:,::1]] meshsupp
    cdef list _asm_pool     # list of shared clones for multithreading

    cdef void base_init(self, kvs):
        assert len(kvs) == 2, "Assembler requires two knot vectors"
        self.nqp = max([kv.p for kv in kvs]) + 1
        self.ndofs[:] = [kv.numdofs for kv in kvs]
        self.meshsupp = [kvs[k].mesh_support_idx_all() for k in range(2)]
        self._asm_pool = []

    cdef _share_base(self, BaseAssembler2D asm):
        asm.nqp = self.nqp
        asm.ndofs[:] = self.ndofs[:]
        asm.meshsupp = self.meshsupp

    cdef BaseAssembler2D shared_clone(self):
        return self     # by default assume thread safety

    cdef inline size_t to_seq(self, size_t[2] ii) nogil:
        # by convention, the order of indices is (y,x)
        return (ii[0]) * self.ndofs[1] + ii[1]

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.cdivision(True)
    cdef inline void from_seq(self, size_t i, size_t[2] out) nogil:
        out[1] = i % self.ndofs[1]
        i /= self.ndofs[1]
        out[0] = i

    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        return -9999.99  # Not implemented

    cpdef double assemble(self, size_t i, size_t j):
        cdef size_t[2] I, J
        with nogil:
            self.from_seq(i, I)
            self.from_seq(j, J)
            return self.assemble_impl(I, J)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef void multi_assemble_chunk(self, size_t[:,::1] idx_arr, double[::1] out) nogil:
        cdef size_t[2] I, J
        cdef size_t k

        for k in range(idx_arr.shape[0]):
            self.from_seq(idx_arr[k,0], I)
            self.from_seq(idx_arr[k,1], J)
            out[k] = self.assemble_impl(I, J)

    def multi_assemble(self, indices):
        cdef size_t[:,::1] idx_arr = np.array(list(indices), dtype=np.uintp)
        cdef double[::1] result = np.empty(idx_arr.shape[0])

        num_threads = pyiga.get_max_threads()
        if num_threads <= 1:
            self.multi_assemble_chunk(idx_arr, result)
        else:
            thread_pool = get_thread_pool()
            if not self._asm_pool:
                self._asm_pool = [self] + [self.shared_clone()
                        for i in range(1, thread_pool._max_workers)]

            results = thread_pool.map(_asm_chunk_2d,
                        self._asm_pool,
                        chunk_tasks(idx_arr, num_threads),
                        chunk_tasks(result, num_threads))
            list(results)   # wait for threads to finish
        return result

cpdef void _asm_chunk_2d(BaseAssembler2D asm, size_t[:,::1] idxchunk, double[::1] out):
    with nogil:
        asm.multi_assemble_chunk(idxchunk, out)


@cython.boundscheck(False)
@cython.wraparound(False)
cdef object generic_assemble_2d(BaseAssembler2D asm, long chunk_start=-1, long chunk_end=-1):
    cdef size_t[2] i, j
    cdef size_t k, ii, jj
    cdef IntInterval intv

    cdef size_t[2] dof_start, dof_end, neigh_j_start, neigh_j_end
    cdef double entry
    cdef vector[double] entries
    cdef vector[size_t] entries_i, entries_j

    dof_start[:] = (0, 0)
    dof_end[:] = asm.ndofs[:]

    if chunk_start >= 0:
        dof_start[0] = chunk_start
    if chunk_end >= 0:
        dof_end[0] = chunk_end

    i[:] = dof_start[:]
    with nogil:
        while True:         # loop over all i
            ii = asm.to_seq(i)

            for k in range(2):
                intv = find_joint_support_functions(asm.meshsupp[k], i[k])
                neigh_j_start[k] = intv.a
                neigh_j_end[k] = intv.b
                j[k] = neigh_j_start[k]

            while True:     # loop j over all neighbors of i
                jj = asm.to_seq(j)
                if jj >= ii:
                    entry = asm.assemble_impl(i, j)

                    entries.push_back(entry)
                    entries_i.push_back(ii)
                    entries_j.push_back(jj)

                    if ii != jj:
                        entries.push_back(entry)
                        entries_i.push_back(jj)
                        entries_j.push_back(ii)

                if not next_lexicographic2(j, neigh_j_start, neigh_j_end):
                    break
            if not next_lexicographic2(i, dof_start, dof_end):
                break

    cdef size_t ne = entries.size()
    cdef size_t N = asm.ndofs[0] * asm.ndofs[1]
    return scipy.sparse.coo_matrix(
            (<double[:ne]> entries.data(),
                (<size_t[:ne]> entries_i.data(),
                 <size_t[:ne]> entries_j.data())),
            shape=(N,N)).tocsr()


cdef generic_assemble_2d_parallel(BaseAssembler2D asm):
    num_threads = pyiga.get_max_threads()
    if num_threads <= 1:
        return generic_assemble_2d(asm)
    def asm_chunk(rg):
        cdef BaseAssembler2D asm_clone = asm.shared_clone()
        return generic_assemble_2d(asm_clone, rg.start, rg.stop)
    results = get_thread_pool().map(asm_chunk, chunk_tasks(range_it(asm.ndofs[0]), 4*num_threads))
    return sum(results)


# helper function for fast low-rank assembler
cdef double _entry_func_2d(size_t i, size_t j, void * data):
    return (<BaseAssembler2D>data).assemble(i, j)

cdef class MassAssembler2D(BaseAssembler2D):
    cdef vector[double[:, :, ::1]] C       # 1D basis values. Indices: basis function, mesh point, derivative(0)
    cdef double[:, ::1] weights

    def __init__(self, kvs, geo):
        assert geo.dim == 2, "Geometry has wrong dimension"
        self.base_init(kvs)

        gauss = [make_iterated_quadrature(np.unique(kv.kv), self.nqp) for kv in kvs]
        gaussgrid = [g[0] for g in gauss]
        gaussweights = [g[1] for g in gauss]

        colloc = [bspline.collocation_derivs(kvs[k], gaussgrid[k], derivs=0) for k in range(2)]
        for k in range(2):
            colloc[k] = tuple(X.T.A for X in colloc[k])
        self.C = [np.stack(Cs, axis=-1) for Cs in colloc]

        geo_jac    = geo.grid_jacobian(gaussgrid)
        geo_det    = determinants(geo_jac)
        self.weights = gaussweights[0][:,None] * gaussweights[1][None,:] * np.abs(geo_det)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]

        for k in range(2):
            intv = intersect_intervals(make_intv(self.meshsupp[k][i[k],0], self.meshsupp[k][i[k],1]),
                                       make_intv(self.meshsupp[k][j[k],0], self.meshsupp[k][j[k],1]))
            if intv.a >= intv.b:
                return 0.0      # no intersection of support
            g_sta[k] = self.nqp * intv.a    # start of Gauss nodes
            g_end[k] = self.nqp * intv.b    # end of Gauss nodes

            values_i[k] = &self.C[k][ i[k], g_sta[k], 0 ]
            values_j[k] = &self.C[k][ j[k], g_sta[k], 0 ]

        return combine_mass_2d(
                self.weights [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_i[0], values_i[1],
                values_j[0], values_j[1]
        )

cdef class StiffnessAssembler2D(BaseAssembler2D):
    cdef vector[double[:, :, ::1]] C            # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, :, ::1] B   # transformation matrix. Indices: DIM x mesh point, i, j

    def __init__(self, kvs, geo):
        assert geo.dim == 2, "Geometry has wrong dimension"
        self.base_init(kvs)

        gauss = [make_iterated_quadrature(np.unique(kv.kv), self.nqp) for kv in kvs]
        gaussgrid = [g[0] for g in gauss]
        gaussweights = [g[1] for g in gauss]

        colloc = [bspline.collocation_derivs(kvs[k], gaussgrid[k], derivs=1) for k in range(2)]
        for k in range(2):
            colloc[k] = tuple(X.T.A for X in colloc[k])
        self.C = [np.stack(Cs, axis=-1) for Cs in colloc]

        geo_jac = geo.grid_jacobian(gaussgrid)
        geo_det, geo_jacinv = det_and_inv(geo_jac)
        weights = gaussweights[0][:,None] * gaussweights[1][None,:] * np.abs(geo_det)
        self.B = matmatT_2x2(geo_jacinv) * weights[ :, :, None, None ]

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[2] i, size_t[2] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[2]
        cdef size_t g_end[2]
        cdef (double*) values_i[2]
        cdef (double*) values_j[2]

        for k in range(2):
            intv = intersect_intervals(make_intv(self.meshsupp[k][i[k],0], self.meshsupp[k][i[k],1]),
                                       make_intv(self.meshsupp[k][j[k],0], self.meshsupp[k][j[k],1]))
            if intv.a >= intv.b:
                return 0.0      # no intersection of support
            g_sta[k] = self.nqp * intv.a    # start of Gauss nodes
            g_end[k] = self.nqp * intv.b    # end of Gauss nodes

            values_i[k] = &self.C[k][ i[k], g_sta[k], 0 ]
            values_j[k] = &self.C[k][ j[k], g_sta[k], 0 ]

        return combine_stiff_2d(
                self.B [ g_sta[0]:g_end[0], g_sta[1]:g_end[1] ],
                values_i[0], values_i[1],
                values_j[0], values_j[1]
        )
################################################################################
# 3D Assemblers
################################################################################

cdef class BaseAssembler3D:
    cdef int nqp
    cdef size_t[3] ndofs
    cdef vector[ssize_t[:,::1]] meshsupp
    cdef list _asm_pool     # list of shared clones for multithreading

    cdef void base_init(self, kvs):
        assert len(kvs) == 3, "Assembler requires two knot vectors"
        self.nqp = max([kv.p for kv in kvs]) + 1
        self.ndofs[:] = [kv.numdofs for kv in kvs]
        self.meshsupp = [kvs[k].mesh_support_idx_all() for k in range(3)]
        self._asm_pool = []

    cdef _share_base(self, BaseAssembler3D asm):
        asm.nqp = self.nqp
        asm.ndofs[:] = self.ndofs[:]
        asm.meshsupp = self.meshsupp

    cdef BaseAssembler3D shared_clone(self):
        return self     # by default assume thread safety

    cdef inline size_t to_seq(self, size_t[3] ii) nogil:
        # by convention, the order of indices is (y,x)
        return ((ii[0]) * self.ndofs[1] + ii[1]) * self.ndofs[2] + ii[2]

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.cdivision(True)
    cdef inline void from_seq(self, size_t i, size_t[3] out) nogil:
        out[2] = i % self.ndofs[2]
        i /= self.ndofs[2]
        out[1] = i % self.ndofs[1]
        i /= self.ndofs[1]
        out[0] = i

    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        return -9999.99  # Not implemented

    cpdef double assemble(self, size_t i, size_t j):
        cdef size_t[3] I, J
        with nogil:
            self.from_seq(i, I)
            self.from_seq(j, J)
            return self.assemble_impl(I, J)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef void multi_assemble_chunk(self, size_t[:,::1] idx_arr, double[::1] out) nogil:
        cdef size_t[3] I, J
        cdef size_t k

        for k in range(idx_arr.shape[0]):
            self.from_seq(idx_arr[k,0], I)
            self.from_seq(idx_arr[k,1], J)
            out[k] = self.assemble_impl(I, J)

    def multi_assemble(self, indices):
        cdef size_t[:,::1] idx_arr = np.array(list(indices), dtype=np.uintp)
        cdef double[::1] result = np.empty(idx_arr.shape[0])

        num_threads = pyiga.get_max_threads()
        if num_threads <= 1:
            self.multi_assemble_chunk(idx_arr, result)
        else:
            thread_pool = get_thread_pool()
            if not self._asm_pool:
                self._asm_pool = [self] + [self.shared_clone()
                        for i in range(1, thread_pool._max_workers)]

            results = thread_pool.map(_asm_chunk_3d,
                        self._asm_pool,
                        chunk_tasks(idx_arr, num_threads),
                        chunk_tasks(result, num_threads))
            list(results)   # wait for threads to finish
        return result

cpdef void _asm_chunk_3d(BaseAssembler3D asm, size_t[:,::1] idxchunk, double[::1] out):
    with nogil:
        asm.multi_assemble_chunk(idxchunk, out)


@cython.boundscheck(False)
@cython.wraparound(False)
cdef object generic_assemble_3d(BaseAssembler3D asm, long chunk_start=-1, long chunk_end=-1):
    cdef size_t[3] i, j
    cdef size_t k, ii, jj
    cdef IntInterval intv

    cdef size_t[3] dof_start, dof_end, neigh_j_start, neigh_j_end
    cdef double entry
    cdef vector[double] entries
    cdef vector[size_t] entries_i, entries_j

    dof_start[:] = (0, 0, 0)
    dof_end[:] = asm.ndofs[:]

    if chunk_start >= 0:
        dof_start[0] = chunk_start
    if chunk_end >= 0:
        dof_end[0] = chunk_end

    i[:] = dof_start[:]
    with nogil:
        while True:         # loop over all i
            ii = asm.to_seq(i)

            for k in range(3):
                intv = find_joint_support_functions(asm.meshsupp[k], i[k])
                neigh_j_start[k] = intv.a
                neigh_j_end[k] = intv.b
                j[k] = neigh_j_start[k]

            while True:     # loop j over all neighbors of i
                jj = asm.to_seq(j)
                if jj >= ii:
                    entry = asm.assemble_impl(i, j)

                    entries.push_back(entry)
                    entries_i.push_back(ii)
                    entries_j.push_back(jj)

                    if ii != jj:
                        entries.push_back(entry)
                        entries_i.push_back(jj)
                        entries_j.push_back(ii)

                if not next_lexicographic3(j, neigh_j_start, neigh_j_end):
                    break
            if not next_lexicographic3(i, dof_start, dof_end):
                break

    cdef size_t ne = entries.size()
    cdef size_t N = asm.ndofs[0] * asm.ndofs[1] * asm.ndofs[2]
    return scipy.sparse.coo_matrix(
            (<double[:ne]> entries.data(),
                (<size_t[:ne]> entries_i.data(),
                 <size_t[:ne]> entries_j.data())),
            shape=(N,N)).tocsr()


cdef generic_assemble_3d_parallel(BaseAssembler3D asm):
    num_threads = pyiga.get_max_threads()
    if num_threads <= 1:
        return generic_assemble_3d(asm)
    def asm_chunk(rg):
        cdef BaseAssembler3D asm_clone = asm.shared_clone()
        return generic_assemble_3d(asm_clone, rg.start, rg.stop)
    results = get_thread_pool().map(asm_chunk, chunk_tasks(range_it(asm.ndofs[0]), 4*num_threads))
    return sum(results)


# helper function for fast low-rank assembler
cdef double _entry_func_3d(size_t i, size_t j, void * data):
    return (<BaseAssembler3D>data).assemble(i, j)

cdef class MassAssembler3D(BaseAssembler3D):
    cdef vector[double[:, :, ::1]] C       # 1D basis values. Indices: basis function, mesh point, derivative(0)
    cdef double[:, :, ::1] weights

    def __init__(self, kvs, geo):
        assert geo.dim == 3, "Geometry has wrong dimension"
        self.base_init(kvs)

        gauss = [make_iterated_quadrature(np.unique(kv.kv), self.nqp) for kv in kvs]
        gaussgrid = [g[0] for g in gauss]
        gaussweights = [g[1] for g in gauss]

        colloc = [bspline.collocation_derivs(kvs[k], gaussgrid[k], derivs=0) for k in range(3)]
        for k in range(3):
            colloc[k] = tuple(X.T.A for X in colloc[k])
        self.C = [np.stack(Cs, axis=-1) for Cs in colloc]

        geo_jac    = geo.grid_jacobian(gaussgrid)
        geo_det    = determinants(geo_jac)
        self.weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:] * np.abs(geo_det)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]

        for k in range(3):
            intv = intersect_intervals(make_intv(self.meshsupp[k][i[k],0], self.meshsupp[k][i[k],1]),
                                       make_intv(self.meshsupp[k][j[k],0], self.meshsupp[k][j[k],1]))
            if intv.a >= intv.b:
                return 0.0      # no intersection of support
            g_sta[k] = self.nqp * intv.a    # start of Gauss nodes
            g_end[k] = self.nqp * intv.b    # end of Gauss nodes

            values_i[k] = &self.C[k][ i[k], g_sta[k], 0 ]
            values_j[k] = &self.C[k][ j[k], g_sta[k], 0 ]

        return combine_mass_3d(
                self.weights [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_i[0], values_i[1], values_i[2],
                values_j[0], values_j[1], values_j[2]
        )

cdef class StiffnessAssembler3D(BaseAssembler3D):
    cdef vector[double[:, :, ::1]] C            # 1D basis values. Indices: basis function, mesh point, derivative
    cdef double[:, :, :, :, ::1] B   # transformation matrix. Indices: DIM x mesh point, i, j

    def __init__(self, kvs, geo):
        assert geo.dim == 3, "Geometry has wrong dimension"
        self.base_init(kvs)

        gauss = [make_iterated_quadrature(np.unique(kv.kv), self.nqp) for kv in kvs]
        gaussgrid = [g[0] for g in gauss]
        gaussweights = [g[1] for g in gauss]

        colloc = [bspline.collocation_derivs(kvs[k], gaussgrid[k], derivs=1) for k in range(3)]
        for k in range(3):
            colloc[k] = tuple(X.T.A for X in colloc[k])
        self.C = [np.stack(Cs, axis=-1) for Cs in colloc]

        geo_jac = geo.grid_jacobian(gaussgrid)
        geo_det, geo_jacinv = det_and_inv(geo_jac)
        weights = gaussweights[0][:,None,None] * gaussweights[1][None,:,None] * gaussweights[2][None,None,:] * np.abs(geo_det)
        self.B = matmatT_3x3(geo_jacinv) * weights[ :, :, :, None, None ]

    @cython.boundscheck(False)
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef double assemble_impl(self, size_t[3] i, size_t[3] j) nogil:
        cdef int k
        cdef IntInterval intv
        cdef size_t g_sta[3]
        cdef size_t g_end[3]
        cdef (double*) values_i[3]
        cdef (double*) values_j[3]

        for k in range(3):
            intv = intersect_intervals(make_intv(self.meshsupp[k][i[k],0], self.meshsupp[k][i[k],1]),
                                       make_intv(self.meshsupp[k][j[k],0], self.meshsupp[k][j[k],1]))
            if intv.a >= intv.b:
                return 0.0      # no intersection of support
            g_sta[k] = self.nqp * intv.a    # start of Gauss nodes
            g_end[k] = self.nqp * intv.b    # end of Gauss nodes

            values_i[k] = &self.C[k][ i[k], g_sta[k], 0 ]
            values_j[k] = &self.C[k][ j[k], g_sta[k], 0 ]

        return combine_stiff_3d(
                self.B [ g_sta[0]:g_end[0], g_sta[1]:g_end[1], g_sta[2]:g_end[2] ],
                values_i[0], values_i[1], values_i[2],
                values_j[0], values_j[1], values_j[2]
        )